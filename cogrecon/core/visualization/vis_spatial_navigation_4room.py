from pyqtgraph.Qt import QtGui, QtCore
import pyqtgraph as pg
import csv
import sys
import argparse
import logging


# TODO: Fix issue with pyqt globals (should not used globals)
def visualize(input_path, point_speed=100, colors='rg', log_level=20):
    # noinspection PyGlobalUndefined
    global p, x, y, ptr, buf_x, buf_y, done, curve, img, ps, cols

    ps = point_speed
    cols = colors

    # Configure the output logger
    logging.basicConfig(format="%(levelname)s (%(asctime)s): %(message)s", level=log_level)

    logging.info("Done parsing command line arguments.")

    p = pg.plot()

    img = QtGui.QImage('flat_no_items.jpg')
    img = img.convertToFormat(QtGui.QImage.Format_ARGB32_Premultiplied)
    imgArray = pg.imageToArray(img, copy=True)
    img = pg.ImageItem(imgArray)
    img.setPxMode(False)
    img.setRect(QtCore.QRectF(-12.5, -2.5, 80, 80))
    img.x = -12.5
    img.y = -2.5
    p.addItem(img)

    fp_reader = open(input_path, 'rb')
    reader = csv.reader(fp_reader)
    # noinspection PyUnusedLocal
    header = reader.next()

    data_dict = dict()

    for line in reader:
        segment_id = line[0] + line[1]
        if segment_id in data_dict:
            data_dict[segment_id].append(line)
        else:
            data_dict[segment_id] = [line]

    logging.info("Done parsing input files into segments. %d segments found. Closing input file." % len(data_dict))

    fp_reader.close()

    if len(data_dict) == 0:
        logging.error("Error: No segments found in input file. Are you sure this is a properly formatted input file?")
        exit()

    x, y = generate_buffered_points(data_dict, '001', '0')
    ptr = 1
    buf_x = [x[0]]
    buf_y = [y[0]]
    done = False

    timer = QtCore.QTimer()
    # noinspection PyUnresolvedReferences
    timer.timeout.connect(update)
    timer.start(33)

    if (sys.flags.interactive != 1) or not hasattr(QtCore, 'PYQT_VERSION'):
        # noinspection PyArgumentList
        QtGui.QApplication.instance().exec_()


def generate_buffered_points(data_dict, subject_id, trial_num):
    internal_id = subject_id + trial_num
    dat = data_dict[internal_id]
    xr = []
    zr = []
    for l in dat:
        xr.append(float(l[3]))
        # zr.append(float(l[4]))
        zr.append(float(l[5]))
    return xr, zr


def update():
    global p, x, y, ptr, buf_x, buf_y, done, curve, img, ps, cols
    p.clear()

    if not done:
        for i in range(0, ps):
            if ptr >= len(x):
                done = True
                break
            buf_x.append(x[ptr])
            buf_y.append(y[ptr])
            ptr += 1
        curve = pg.PlotCurveItem(x=buf_x, y=buf_y, pen=cols[0], symbol='o', brush='b', size=1)
    else:
        curve = pg.PlotCurveItem(x=buf_x, y=buf_y, pen=cols[1], symbol='o', brush='b', size=1)
    p.addItem(img)
    p.addItem(curve)
    p.repaint()

if __name__ == "__main__":
    # Parse inputs
    parser = argparse.ArgumentParser(
        description='This script will process a *_path.csv file (first input arg) and generate basic exploration '
                    'metrics (distance, time, distance/time) for the various segments of data (a segment is any '
                    'section of data points which share a subject_id, trial_number, room_by_order/room_by_color). The '
                    'data will be saved in the output_path parameter (second input arg) in csv format.')
    parser.add_argument('path', help='The full input path to the *_path.csv file generated by ' +
                                     'Holodeck_GenerateIntermediateFiles.py that you wish to process.')

    parser.add_argument('--point_speed', default=100, type=int,
                        help='The number of points to be drawn per 33ms iteration.')
    parser.set_defaults(point_speed=100)

    parser.add_argument('--colors', default='rg', type=str,
                        help='The pyqtgraph format colors (in order no spaces or symbols - active, complete). ' +
                             'Example: rg, red would be active color, g would be complete color.')
    parser.set_defaults(colors='rg')

    parser.add_argument('--log_level', default=20, type=int,
                        help='Logging level of the application (default=20/INFO). ' +
                             'See https://docs.python.org/2/library/logging.html#levels for more info.')
    parser.set_defaults(log_level=20)

    args = parser.parse_args()

    visualize(args.path, args.point_speed, args.colors, args.log_level)
